package docker

import (
	"context"
	"strings"

	"github.com/docker/docker/api/types/volume"
	"github.com/openconfig/containerz/containers"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	cpb "github.com/openconfig/gnoi/containerz"
)

// VolumeCreate creates a volume with the provided name using the driver specified. The driver
// default to LOCAL if it is not specified. The name is autogenerated by the target if it is empty.
func (m *Manager) VolumeCreate(ctx context.Context, name string, driver cpb.Driver, opts ...options.Option) (string, error) {
	optionz := options.ApplyOptions(opts...)

	kind := "local"
	volOpts := map[string]string{}
	switch driver {
	case cpb.Driver_DS_UNSPECIFIED, cpb.Driver_DS_LOCAL:
		kind = "local"
		if optionz.VolumeDriverOptions != nil {
			vopts, ok := optionz.VolumeDriverOptions.(*cpb.LocalDriverOptions)
			if !ok {
				return "", status.Error(codes.InvalidArgument, "driver is marked as local but options are not LocalDriverOptions")
			}
			switch vopts.GetType() {
			case cpb.LocalDriverOptions_TYPE_UNSPECIFIED, cpb.LocalDriverOptions_TYPE_NONE:
				volOpts["type"] = "none"
			}

			volOpts["o"] = strings.Join(vopts.GetOptions(), ",")
			volOpts["device"] = vopts.GetMountpoint()
		}
	case cpb.Driver_DS_CUSTOM:
		kind = "custom"
		if optionz.VolumeDriverOptions != nil {
			vopts, ok := optionz.VolumeDriverOptions.(*cpb.CustomOptions)
			if !ok {
				return "", status.Error(codes.InvalidArgument, "driver is marked as custom but options are not CustomOptions")
			}
			volOpts = vopts.GetOptions()
		}
	}

	create := volume.CreateOptions{
		Name:       name,
		Driver:     kind,
		Labels:     optionz.VolumeLabels,
		DriverOpts: volOpts,
	}

	v, err := m.client.VolumeCreate(ctx, create)
	if err != nil {
		return "", err
	}
	return v.Name, nil
}
